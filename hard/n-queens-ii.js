/**
 * 回溯
 * 位运算
 * 用一个数的二进制数来表示棋盘上能放置皇后的位置，1表示能放置0表示不能放置
 *  二进制右侧的最低位位棋盘上左侧的起始位置
 * 每当放置一个皇后后用位运算把这个位置置0，并且存储列和斜角的两个数也都用位运算更新
 */
var totalNQueens = function(n) {
  let res = 0;
  dfs(n, 0, 0, 0, 0);
  return res;
  function dfs(n, row, col, ld, rd){
    // 当行数已经大于棋盘尺寸时解决方案+1
    if(row >= n){
      res++;
      return;
    }
    // ~(col | ld | rd)按位或 当前层列和斜线不能放置皇后的位置,取反后则为能放皇后的位置
    // (1 << n) - 1 能到一个n位的二进制上全是1的数
    // 这一步就是把上面两个按位与后取得的数,转换成二进制后为1的位置都为能放置皇后的位置
    let bits = ~(col | ld | rd) & ((1 << n) - 1);
    // 只要bits>0就说明还能放皇后
    while(bits > 0){
      // 与自身负数按位与能取得二进制上最低位的1,则当前就在最低位1的位置上放皇后
      let pick = bits & -bits;
      // col | pick 得到的为所有放了皇后的位置
      // 因为二进制数上的最第位表示的是棋盘上最左侧的位置,所以左移右移位运算是反过来的
      // (ld | pick) << 1 把当前皇后为后和上一层皇后左斜下来占用的位置合并后左移一位表示下一层不可选择的位置
      // (rd | pick) >> 1 把当前皇后为后和上一层皇后右斜下来占用的位置合并后右移一位表示下一层不可选择的位置
      dfs(n, row + 1, col | pick, (ld | pick) << 1, (rd | pick) >> 1);
      // 把二进制中最低位的1置为0表示一个位置已经被放置皇后
      bits &= bits - 1;
    }
  }
};
