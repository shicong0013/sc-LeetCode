/**
 * 动态规划
 * 假设当n为5时
 *  以3为根的二叉搜索树的左子树由3-1个节点
 *  右子树为5-3个节点
 * 则dp[3] += dp[2] * dp[2]
 * 最外层的循环迭代至n，i为构建树节点的数量
 *  内层循环为当前数量中从1开始为根节点的树
 * 边界情况
 *  当节点只有一个或者为空节点时，树的情况都只有一种
 *  dp[0] = 1
 *  dp[1] = 1
 * dp[i] 的结果为每次不同数量的左右子树相乘后的和
 */

var numTrees = function(n) {
  var dp = new Array(n+1).fill(0);
  dp[0] = 1;
  dp[1] = 1;
  for(let i = 2; i <= n; i++){
    for(let j = 1; j <= i; j++){
      dp[i] += dp[j-1] * dp[i-j];
    }
  }
  return dp[n];
};
